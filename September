<----------------------------------------------------------------------03/09/2024-------------------------------------------------------------------------------->
                                                  53. Maximum Subarray on leetcode(Using Kadane's algo):
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        int n=nums.size();
        int sum=0;
        int curr=nums[0];
        for(int i=0;i<n;i++)
        {
            sum=sum+nums[i];
            if (sum>curr)
            {
                curr = sum;
            }
            if(sum<0)
            {
                sum=0;
            }
        }
        return curr;
    }
};
<----------------------------------------------------------------------04/09/2024-------------------------------------------------------------------------------->
                                                              11. Container With Most Water
class Solution {
public:
    int maxArea(vector<int>& height) {
        int max=0,l=0,r=height.size()-1,cur=0;
        while(l<r)
        {
            if(height[l]<height[r])
            {
                cur=(r-l)*height[l];
                l++;
            }
            else
            {
                cur=(r-l)*height[r];
                r--;
            }
            if(cur>max)
            {
                max=cur;
            }
        }
        return max;
    }
};
<--------------------------------------------------------------------05/09/2024-------------------------------------------------------------------------------->
                                                                  202. Happy Number
First solution with Flyod's cycle detection algo:                         |  Second solution:
class Solution {                                                          |  class Solution {
public:                                                                   |  public:
    int sumD(int n) {                                                     |        bool isHappy(int n) {
        int s=0;                                                          |                int s=0;
        while(n!=0) {                                                     |                if(n==1)
            int r= n%10;                                                  |                return true;
            s += r*r;                                                     |                if(n<7&&n!=1)
            n = n/10;                                                     |                return false;
        }                                                                 |                while(n>0) {
        return s;                                                         |                     int r=n%10;
    }                                                                     |                     s+=r*r;
    bool isHappy(int n) {                                                 |                     n=n/10;
            int slow = sumD(n);                                           |                 }
            int fast = sumD(sumD(n));                                     |               return isHappy(s);    
            while(slow!=fast && fast!=1) {                                |             }
                slow = sumD(slow);                                        |         };
                fast = sumD(sumD(fast));                                  |
            }                                                             |
            if(fast==1) {                                                 |
                return true;                                              |
            }                                                             |
            else {                                                        |
               return false;                                              |
            }                                                             |
        }                                                                 |               
    }                                                                     |
};                                                                        |
<----------------------------------------------------------------------06/09/2024-------------------------------------------------------------------------------->
                                                        1877. Minimize Maximum Pair Sum in Array
class Solution {
public:
    int minPairSum(vector<int>& nums) {
        sort(nums.begin(),nums.end());
        int l=0,r=nums.size()-1,sum=INT_MIN;
        while(l<r) {
            int max=nums[l]+nums[r];
            if(max>sum) {
                sum=max;
            }
            l++;
            r--;
        }
        return sum;
    }
};
<----------------------------------------------------------------------07/09/2024-------------------------------------------------------------------------------->
                                                            503. Next Greater Element II
class Solution {
public:
    vector<int> nextGreaterElements(vector<int>& nums) {
        stack<int>s;
        vector<int>ans;
        int n=nums.size();
        for(int i=2*n-1;i>=0;i--) {
            while(!s.empty() && s.top()<=nums[i%n]) {
                s.pop();
            }
            if(i<n) {
                int a=s.empty()?-1:s.top();
                ans.push_back(a);
            }
            s.push(nums[i%n]);
        }
        reverse(ans.begin(),ans.end());
        return ans;
    }
};
                                                                   2. Add Two Numbers
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        ListNode* l3 = new ListNode(0);
        int carry=0;
        ListNode* head = l3;
        while(l1!=NULL && l2!=NULL) {
            int value = l1->val + l2->val + carry;
            carry = value/10;
            l3->next = new ListNode(value%10);
            l1=l1->next;
            l2=l2->next;
            l3=l3->next;
        }
        while(l1!=NULL) {
            int value = l1->val + carry;
            carry = value/10;
            l3->next = new ListNode(value%10);
            l1=l1->next;
            l3=l3->next;
        }
        while(l2!=NULL) {
            int value =l2->val + carry;
            carry = value/10;
            l3->next = new ListNode(value%10);
            l2=l2->next;
            l3=l3->next;
        }
        if(carry!=0) {
            l3->next = new ListNode(carry);
        }
        return head->next;
    }
};
<----------------------------------------------------------------------08/09/2024-------------------------------------------------------------------------------->
                                                                  13. Roman to Integer
class Solution {
public:
    int romanToInt(string s) {
        map<char, int> mp ={{'I', 1}, {'V', 5}, {'X', 10}, {'L', 50}, {'C', 100}, {'D', 500}, {'M', 1000}};
        int sum=0;
        for(int i=0;i<s.length();i++) {
            if(mp[s[i]]<mp[s[i+1]]) {
                sum-=(mp[s[i]]);
            }
            else {
                sum+=mp[s[i]];
            }
        }
        return sum;
    }
};
                                                              238. Product of Array Except Self
class Solution {
public:
    vector<int> productExceptSelf(vector<int>& nums) {
        int a=0,p=1,c=0;
        for(int i=0;i<nums.size();i++) {
            if(nums[i]==0) {
                a=i;
                c++;
                continue;
            }
            else {
                p=p*nums[i];
            }
        }
        for(int i=0;i<nums.size();i++) {
            if(c>1) {
                nums[i]=0;    
            }
            else {
                if(c>0 && a!=i) {
                    nums[i]=0;
                }
                else if(c>0 && a==i) {
                    nums[i]=p;
                }
                else {
                    nums[i]=p/nums[i];
                }
            }
            
        }
        return nums;
    }
};
<----------------------------------------------------------------------09/09/2024-------------------------------------------------------------------------------->
                                                                    263. Ugly Number
class Solution {
public:
    bool isUgly(int n) {
        
        if(n<1){
            return false;
        }
        while(n>1) {
            if(n%2==0) {
                n=n/2;
            }
            else if(n%3==0) {
                n=n/3;
            }
            else if(n%5==0) {
                n=n/5;
            }
            else {
                return false;
            }
        }
        return true;
    }
};
